## 知识点
1. 当import里导入包时，可以存在在导入包的路径前加一个下划线。
   这么做的原因就是：Go的编译器不允许声明某个包却不使用。下划线让编译器接收这类的导入，并且调用对应包内的所有代码文件里定义的init函数。
***
2. 关于init函数。程序中，每个代码文件的init函数都会在main函数前执行调用。
***
3. 在Go语言中，如果main函数返回，那么整个程序也就被终止了。Go程序终止时，还会关闭所有之前启动且还在运行的goroutine。在写并发程序的时候，最佳的做法就是，在main函数返回前，清理并终止所有之前启动的goroutine。
***
4. 查找map里的键时，有两种选择：一个是赋值给一个变量值。另一个是赋值给两个变量值。赋值给两个变量时，第一个值 与 赋值给一个变量值是一样的，为map查找的结果值。第二个值是一个布尔标识，标识查找的键是否在map中。
***
5. Go语言中，所有的变量都是以值的方式传递的。因为指针变量的值是指向变量的地址，在函数之间传递指针变量，是在传递这个地址值，所以也可以被看作是以值的方式在传递。
***
6. 闭包：能够读取其他函数内部变量的函数。因为有了闭包，所以写在函数内的匿名函数可以读取到并未通过参数列表传入匿名函数内部的变量的值，并且每个goroutine的匿名函数共享这些变量。下面的例子里，key1没通过匿名函数的参数列表即被使用，这里可能提出一个问题，那匿名函数的val也能如此被传入，为什么还要加一个参数列表？答案是，如果使用闭包访问这些变量，随着外层函数里变量值的改变，内层匿名函数也可以感受到这些改变。所有的goroutine都会因为闭包共享同样的变量。除非使用参数列表形式传递给匿名函数，否则大部分的函数都会处理相同的值。总结，变的值使用参数列表传递，不变的使用闭包传递。
```go
    func func1() {
        var key1 int
        for _,val := range vals {
            go func(val Type){
                fmt.Println(key1)
                fmt.Println(val)
            }(val)
        }
    }
```
***
7. sync.WaitGroup 的 Wait函数会使goroutine阻塞，直到WaitGroup的内部计数为0
***
8. 函数defer会安排随后的函数调用在函数返回后才执行。即使函数意外崩溃终止，defer也会安排调用的函数会被执行。
***
9. 接口在命名的时候，需要遵守Go的命名规则。如果接口类型只包含一个方法，那么这个类型的名字应该以er结尾。如果接口类型里声明了多个方法，那么名字就需要与其行为相关联。
***
10. 空结构在创建实例的时候，不会分配任何内存。这种结构很适合创建没有任何状态的类型。例如:
```go
    type defaultMatcher struct{}
```
***
11. 如果声明函数的时候带有接收者，那么就是声明了一个方法。有两种，一种方法的接受者是接受者类型的值，另一种的接收者是接受者类型的指针。区别，为值的不会保存接受者值的状态，为指针的会。接收者为指针的方法，只能通过指针去调(Go1.11.5也可以用值去调接收值为指针的方法)，但是接收者为值的方法，可以用值，也可以用指针去调。
***
12. 当对于一个chan做for-loop的时候，chan会一直阻塞除非有数据写入。只有当chan被close之后，for-loop才会终止。
```go
    var results *chan
    for res := ranges results {
        fmt.Println(res)
    }
```
***
